# Pipeline GitLab CI/CD pour SparkFit Backend
# Ce pipeline gère les tests, le build et le déploiement du backend

stages:
  - test
  - build
  - deploy

variables:
  # Variables globales
  NODE_VERSION: "18"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  
  # Variables pour Prisma (répertoire à la racine)
  PRISMA_SCHEMA_PATH: "../sparkfit_prisma-schema"
  
  # Variables pour les tests
  NODE_ENV: "test"
  JWT_SECRET: "test-secret-key"
  PORT: "3001"
  
  # Variables pour la base de données de test
  DATABASE_URL: "postgresql://myuser:mypassword@localhost:5432/test_database"

# Cache pour optimiser les builds
cache:
  key: 
    files:
      - package-lock.json
  paths:
    - node_modules/
    - .npm/

# Job de test
test:
  stage: test
  image: node:${NODE_VERSION}-alpine
  services:
    - postgres:13
  variables:
    POSTGRES_DB: test_database
    POSTGRES_USER: myuser
    POSTGRES_PASSWORD: mypassword
    POSTGRES_HOST_AUTH_METHOD: trust
  before_script:
    # Installation des dépendances
    - npm ci --only=production
    - npm ci --only=dev
    
    # Configuration de la base de données de test
    - echo "Configuration de la base de données de test..."
    - apk add --no-cache postgresql-client
    
    # Attendre que PostgreSQL soit prêt
    - until pg_isready -h postgres -p 5432 -U myuser; do
        echo "En attente de PostgreSQL..."
        sleep 2
      done
    
    # Copier le schéma Prisma depuis le répertoire racine
    - echo "Copie du schéma Prisma..."
    - cp -r ${PRISMA_SCHEMA_PATH}/schema.prisma ./prisma/
    - cp -r ${PRISMA_SCHEMA_PATH}/migrations ./prisma/
    
    # Générer le client Prisma
    - npx prisma generate --schema=./prisma/schema.prisma
    
    # Appliquer les migrations de test
    - npx prisma migrate deploy --schema=./prisma/schema.prisma
    
    # Vérifier la connexion à la base de données
    - npx prisma db seed --schema=./prisma/schema.prisma || true
  script:
    # Exécuter les tests avec couverture
    - echo "Exécution des tests..."
    - npm run test:coverage
    
    # Vérifier la qualité du code (optionnel)
    - echo "Vérification de la qualité du code..."
    - npm audit --audit-level=moderate || true
  after_script:
    # Nettoyage
    - echo "Nettoyage après les tests..."
    - rm -rf node_modules
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
    expire_in: 1 week
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_BRANCH =~ /^feature\/.*$/
    - if: $CI_COMMIT_BRANCH =~ /^hotfix\/.*$/

# Job de build Docker
build:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$CI_PROJECT_DIR/.certs"
  before_script:
    # Configuration Docker
    - echo "Configuration Docker..."
    - docker info
    
    # Login au registry GitLab (si configuré)
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY || true
  script:
    # Build de l'image Docker
    - echo "Build de l'image Docker..."
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker build -t $CI_REGISTRY_IMAGE:latest .
    
    # Push des images
    - echo "Push des images Docker..."
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
  after_script:
    # Nettoyage des images locales
    - docker rmi $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA || true
    - docker rmi $CI_REGISTRY_IMAGE:latest || true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Job de déploiement en staging
deploy:staging:
  stage: deploy
  image: alpine:latest
  before_script:
    # Installation des outils nécessaires
    - apk add --no-cache curl openssh-client
    - eval $(ssh-agent -s)
    - echo "$STAGING_SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$STAGING_SSH_KNOWN_HOSTS" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    # Déploiement en staging
    - echo "Déploiement en staging..."
    - ssh $STAGING_USER@$STAGING_HOST "cd $STAGING_PATH && docker-compose pull && docker-compose up -d"
  environment:
    name: staging
    url: https://staging.sparkfit.com
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
  only:
    - main
    - develop

# Job de déploiement en production
deploy:production:
  stage: deploy
  image: alpine:latest
  before_script:
    # Installation des outils nécessaires
    - apk add --no-cache curl openssh-client
    - eval $(ssh-agent -s)
    - echo "$PRODUCTION_SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$PRODUCTION_SSH_KNOWN_HOSTS" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    # Déploiement en production
    - echo "Déploiement en production..."
    - ssh $PRODUCTION_USER@$PRODUCTION_HOST "cd $PRODUCTION_PATH && docker-compose pull && docker-compose up -d"
  environment:
    name: production
    url: https://api.sparkfit.com
  rules:
    - if: $CI_COMMIT_TAG
      when: manual
  only:
    - tags

# Job de sécurité et audit
security:audit:
  stage: test
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --only=production
    - npm ci --only=dev
  script:
    # Audit de sécurité npm
    - echo "Audit de sécurité npm..."
    - npm audit --audit-level=moderate
    
    # Vérification des vulnérabilités connues
    - echo "Vérification des vulnérabilités..."
    - npm audit fix --dry-run || true
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Job de validation du schéma Prisma
prisma:validate:
  stage: test
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --only=production
    - npm ci --only=dev
    
    # Copier le schéma Prisma
    - cp -r ${PRISMA_SCHEMA_PATH}/schema.prisma ./prisma/
    - cp -r ${PRISMA_SCHEMA_PATH}/migrations ./prisma/
  script:
    # Validation du schéma Prisma
    - echo "Validation du schéma Prisma..."
    - npx prisma validate --schema=./prisma/schema.prisma
    
    # Génération du client Prisma
    - echo "Génération du client Prisma..."
    - npx prisma generate --schema=./prisma/schema.prisma
    
    # Vérification de la syntaxe
    - echo "Vérification de la syntaxe..."
    - npx prisma format --schema=./prisma/schema.prisma --write
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Job de notification Slack (optionnel)
notify:slack:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - |
      if [ "$CI_JOB_STATUS" == "success" ]; then
        curl -X POST -H 'Content-type: application/json' \
          --data '{
            "text": "✅ Pipeline SparkFit Backend réussi!",
            "attachments": [{
              "fields": [
                {"title": "Projet", "value": "$CI_PROJECT_NAME", "short": true},
                {"title": "Branche", "value": "$CI_COMMIT_REF_NAME", "short": true},
                {"title": "Commit", "value": "$CI_COMMIT_SHORT_SHA", "short": true},
                {"title": "Pipeline", "value": "$CI_PIPELINE_URL", "short": true}
              ]
            }]
          }' \
          $SLACK_WEBHOOK_URL || true
      else
        curl -X POST -H 'Content-type: application/json' \
          --data '{
            "text": "❌ Pipeline SparkFit Backend échoué!",
            "attachments": [{
              "fields": [
                {"title": "Projet", "value": "$CI_PROJECT_NAME", "short": true},
                {"title": "Branche", "value": "$CI_COMMIT_REF_NAME", "short": true},
                {"title": "Commit", "value": "$CI_COMMIT_SHORT_SHA", "short": true},
                {"title": "Pipeline", "value": "$CI_PIPELINE_URL", "short": true}
              ]
            }]
          }' \
          $SLACK_WEBHOOK_URL || true
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG
  allow_failure: true 