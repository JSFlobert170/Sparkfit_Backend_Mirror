# ========================================
# GITLAB CI/CD PIPELINE - SPARKFIT BACKEND
# ========================================
# Ce fichier d√©finit les √©tapes automatis√©es qui s'ex√©cutent
# quand vous poussez du code sur GitLab

# D√©finition des √©tapes (stages) dans l'ordre d'ex√©cution
stages:
  - test      # 1. Tests unitaires
  - build     # 2. Construction de l'image Docker
  - deploy    # 3. D√©ploiement (optionnel)

# Variables globales pour toute la pipeline
variables:
  # Image Docker de base pour les jobs
  DOCKER_IMAGE: node:18-alpine
  # Nom de l'image Docker √† construire
  IMAGE_NAME: sparkfit-backend
  # Tag de l'image (utilise le SHA du commit)
  IMAGE_TAG: $CI_COMMIT_SHORT_SHA

# ========================================
# √âTAPE 1: TESTS UNITAIRES
# ========================================
test:
  # Cette √©tape s'ex√©cute sur les branches develop et main
  only:
    - develop
    - main
  
  # Nom de l'√©tape
  stage: test
  
  # Image Docker √† utiliser
  image: $DOCKER_IMAGE
  
  # Services n√©cessaires (base de donn√©es pour les tests)
  services:
    - postgres:13-alpine
  
  # Variables d'environnement pour les tests
  variables:
    # Configuration de la base de donn√©es de test
    POSTGRES_DB: test_db
    POSTGRES_USER: test_user
    POSTGRES_PASSWORD: test_password
    DATABASE_URL: "postgresql://test_user:test_password@postgres:5432/test_db"
    NODE_ENV: test
    JWT_SECRET: test-secret-key
  
  # Scripts √† ex√©cuter
  script:
    # 1. Afficher les informations de debug
    - echo "üöÄ D√©but des tests pour le commit: $CI_COMMIT_SHORT_SHA"
    - echo "üìÅ R√©pertoire de travail: $CI_PROJECT_DIR"
    - echo "üê≥ Image Docker: $DOCKER_IMAGE"
    
    # 2. Installer les d√©pendances
    - echo "üì¶ Installation des d√©pendances..."
    - npm ci --only=production
    
    # 3. Attendre que la base de donn√©es soit pr√™te
    - echo "‚è≥ Attente de la base de donn√©es..."
    - sleep 10
    
    # 4. Ex√©cuter les migrations Prisma
    - echo "üóÑÔ∏è Ex√©cution des migrations Prisma..."
    - npx prisma migrate deploy
    
    # 5. Ex√©cuter les tests
    - echo "üß™ Ex√©cution des tests unitaires..."
    - npm test
    
    # 6. Afficher les r√©sultats
    - echo "‚úÖ Tests termin√©s avec succ√®s!"
  
  # Artifacts √† conserver apr√®s les tests
  artifacts:
    # Conserver les rapports de couverture de code
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    # Conserver les logs de test
    paths:
      - coverage/
      - test-results/
    # Conserver pendant 7 jours
    expire_in: 1 week

# ========================================
# √âTAPE 2: CONSTRUCTION DE L'IMAGE DOCKER
# ========================================
build:
  # Cette √©tape s'ex√©cute seulement si les tests passent
  # et sur les branches develop et main
  only:
    - develop
    - main
  
  # Nom de l'√©tape
  stage: build
  
  # Utiliser Docker-in-Docker
  image: docker:20.10.16
  
  # Services n√©cessaires
  services:
    - docker:20.10.16-dind
  
  # Variables d'environnement
  variables:
    # Activer Docker-in-Docker
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$CI_PROJECT_DIR/certs/client"
  
  # Scripts √† ex√©cuter
  script:
    # 1. Afficher les informations de debug
    - echo "üî® D√©but de la construction de l'image Docker"
    - echo "üì¶ Image: $IMAGE_NAME:$IMAGE_TAG"
    
    # 2. Se connecter au registry Docker (si configur√©)
    # - echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin
    
    # 3. Construire l'image Docker
    - echo "üèóÔ∏è Construction de l'image..."
    - docker build -t $IMAGE_NAME:$IMAGE_TAG .
    - docker build -t $IMAGE_NAME:latest .
    
    # 4. Afficher les images construites
    - echo "üìã Images construites:"
    - docker images | grep $IMAGE_NAME
    
    # 5. Tester l'image (optionnel)
    - echo "üß™ Test de l'image..."
    - docker run --rm $IMAGE_NAME:$IMAGE_TAG npm test
    
    # 6. Pousser l'image vers le registry (si configur√©)
    # - docker push $IMAGE_NAME:$IMAGE_TAG
    # - docker push $IMAGE_NAME:latest
    
    - echo "‚úÖ Construction termin√©e avec succ√®s!"
  
  # Artifacts √† conserver
  artifacts:
    paths:
      - docker-images/
    expire_in: 1 month

# ========================================
# √âTAPE 3: D√âPLOIEMENT (OPTIONNEL)
# ========================================
deploy_staging:
  # Cette √©tape s'ex√©cute seulement sur develop
  only:
    - develop
  
  # Nom de l'√©tape
  stage: deploy
  
  # Image Docker √† utiliser
  image: alpine:latest
  
  # Scripts √† ex√©cuter
  script:
    - echo "üöÄ D√©ploiement en staging..."
    - echo "üì¶ Image: $IMAGE_NAME:$IMAGE_TAG"
    - echo "üåê Environnement: staging"
    
    # Ici vous ajouteriez vos commandes de d√©ploiement
    # Par exemple:
    # - kubectl set image deployment/sparkfit-backend sparkfit-backend=$IMAGE_NAME:$IMAGE_TAG
    # - kubectl rollout status deployment/sparkfit-backend
    
    - echo "‚úÖ D√©ploiement en staging termin√©!"
  
  # Environnement de d√©ploiement
  environment:
    name: staging
    url: https://staging.sparkfit.com

deploy_production:
  # Cette √©tape s'ex√©cute seulement sur main
  only:
    - main
  
  # Nom de l'√©tape
  stage: deploy
  
  # Image Docker √† utiliser
  image: alpine:latest
  
  # Scripts √† ex√©cuter
  script:
    - echo "üöÄ D√©ploiement en production..."
    - echo "üì¶ Image: $IMAGE_NAME:$IMAGE_TAG"
    - echo "üåê Environnement: production"
    
    # Ici vous ajouteriez vos commandes de d√©ploiement
    # Par exemple:
    # - kubectl set image deployment/sparkfit-backend sparkfit-backend=$IMAGE_NAME:$IMAGE_TAG
    # - kubectl rollout status deployment/sparkfit-backend
    
    - echo "‚úÖ D√©ploiement en production termin√©!"
  
  # Environnement de d√©ploiement
  environment:
    name: production
    url: https://sparkfit.com
  
  # D√©ploiement manuel (n√©cessite une validation)
  when: manual

# ========================================
# CONFIGURATIONS GLOBALES
# ========================================

# Cache pour acc√©l√©rer les builds
cache:
  key: "$CI_COMMIT_REF_SLUG"
  paths:
    - node_modules/
    - .npm/

# Configuration des notifications
# (d√©commentez et configurez selon vos besoins)
# notifications:
#   email:
#     recipients:
#       - dev-team@sparkfit.com
#   slack:
#     webhook: $SLACK_WEBHOOK_URL
#     channel: '#deployments'

# ========================================
# EXEMPLE D'UTILISATION
# ========================================
# 
# 1. Poussez du code sur la branche 'develop':
#    git push origin develop
#    ‚Üí D√©clenche: test ‚Üí build ‚Üí deploy_staging
#
# 2. Mergez develop vers main:
#    git checkout main
#    git merge develop
#    git push origin main
#    ‚Üí D√©clenche: test ‚Üí build ‚Üí deploy_production (manuel)
#
# 3. Surveillez la pipeline:
#    - Allez sur GitLab > Votre projet > CI/CD > Pipelines
#    - Cliquez sur un pipeline pour voir les d√©tails
#    - V√©rifiez les logs de chaque √©tape
#
# ========================================
